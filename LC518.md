# Coin Change II

## 问题描述

这是一个关于完全背包问题的 LeetCode 问题，可以在 [此处](https://leetcode.cn/problems/coin-change-ii/) 查看。

## 代码实现

以下是解决这个问题的 C++ 代码：

```cpp
#include <vector>
#include <climits>
using namespace std;

class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0); // dp[j] 表示凑成金额 j 的组合数。
        dp[0] = 1; // 0 的时候只有一种方法
        for (int i = 0; i < coins.size(); i++) {
            for (int j = coins[i]; j <= amount; ++j) { // 记得 j 要等于 amount
                if (dp[j] < INT_MAX - dp[j - coins[i]]) { // 因为 case 中有一个大 case 和超过 int，所以要做前置的处理
                    dp[j] += dp[j - coins[i]];
                }
            }
        }
        return dp[amount]; // 返回 dp[amount]
    }
};
```

## 代码解释

这段代码实现了一个解决“硬币兑换 II”问题的动态规划算法。以下是代码的详细解释：

### 输入约束

1. 总金额 `amount` 为一个非负整数。
2. 硬币种类数组 `coins` 包含不同面值的硬币。

### 动态规划数组 `dp` 的定义

- `dp[j]` 表示凑成金额 `j` 的组合数。

### 初始化

- 使用一个长度为 `amount + 1` 的数组 `dp`，初始值为 0。
- `dp[0] = 1`，表示凑成金额 0 的方法只有一种，即不使用任何硬币。

### 动态规划状态转移

对于每种硬币 `coins[i]`，从金额 `coins[i]` 开始到 `amount`，更新 `dp` 数组：

```cpp
for (int i = 0; i < coins.size(); i++) {
    for (int j = coins[i]; j <= amount; ++j) {
        if (dp[j] < INT_MAX - dp[j - coins[i]]) {
            dp[j] += dp[j - coins[i]];
        }
    }
}
```

### 返回结果

计算并返回凑成总金额 `amount` 的组合数：

```cpp
return dp[amount];
```

通过这种方式，我们可以正确地计算凑成指定金额的不同组合数。