# Climbing Stairs

## 问题描述

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

## 代码实现

以下是解决这个问题的 C++ 代码：

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;

        for (int j = 1; j <= n; j++) { // 遍历楼梯阶数
            for (int i = 1; i <= 2; i++) { // 遍历步数
                if (j >= i) {
                    dp[j] += dp[j - i];
                }
            }
        }
        return dp[n];
    }
};
```

## 代码解释

这段代码实现了一个解决“爬楼梯”问题的动态规划算法。以下是代码的详细解释：

### 输入约束

1. `n` 是一个正整数，表示楼梯的总阶数。

### 动态规划数组 `dp` 的定义

- `dp[j]` 表示爬到第 `j` 阶楼梯的方法总数。

### 初始化

- 使用一个长度为 `n + 1` 的数组 `dp`，初始值为 0。
- `dp[0] = 1`，表示从第 0 阶楼梯开始的方法有 1 种，即什么都不做。

### 动态规划状态转移

对于每个楼梯阶数 `j`，遍历从 1 到 2 的所有步数 `i`，更新 `dp` 数组：

```cpp
for (int j = 1; j <= n; j++) { // 遍历楼梯阶数
    for (int i = 1; i <= 2; i++) { // 遍历步数
        if (j >= i) {
            dp[j] += dp[j - i];
        }
    }
}
```

### 返回结果

计算并返回爬到第 `n` 阶楼梯的方法总数：

```cpp
return dp[n];
```

通过这种方式，我们可以正确地计算出爬到楼顶的不同方法总数。

## 总结

这个完全背包问题要求我们设计一个算法来找到爬到楼顶的不同方法总数。由于每种步数可以使用多次，并且组合与顺序无关，我们选择先遍历楼梯阶数，再遍历步数。通过动态规划的方法，我们可以有效地解决这个问题。

## 参考

解题思路类似于LC377，属于完全背包的排列问题。先遍历背包容量，后遍历物品。