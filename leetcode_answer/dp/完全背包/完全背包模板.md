# 完全背包模板

完全背包问题是一种典型的动态规划问题。这里提供一个经典的完全背包模板，供你在解决类似问题时参考。

## 完全背包问题描述

给定一个容量为 `bagWeight` 的背包和 `n` 个物品，每个物品有一个体积和价值。每种物品可以选无限次，求解如何选择物品使得背包内的总价值最大。

## 动态规划思路

- **状态定义**: `dp[j]` 表示容量为 `j` 的背包能够获得的最大价值。
- **状态转移方程**: 对于每个物品，更新 `dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`。
- **初始化**: `dp[0] = 0`，其他 `dp[j]` 初始化为 0。
- **遍历顺序**: 因为每种物品可以选无限次，所以内层循环应该是正序遍历。

## 代码模板

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int completeKnapsack(int bagWeight, vector<int>& weights, vector<int>& values) {
        // dp[j] 表示容量为 j 的背包能够获得的最大价值
        vector<int> dp(bagWeight + 1, 0);

        // 遍历每个物品
        for (int i = 0; i < weights.size(); i++) {
            // 遍历背包容量，正序遍历
            for (int j = weights[i]; j <= bagWeight; j++) {
                dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
            }
        }

        // 返回容量为 bagWeight 的背包能够获得的最大价值
        return dp[bagWeight];
    }
};
```

## 示例

假设有一个背包容量为 10，有 3 个物品，其重量分别为 1, 3, 4，价值分别为 15, 20, 30。求解该背包能够获得的最大价值。

```cpp
int main() {
    Solution solution;
    int bagWeight = 10;
    vector<int> weights = {1, 3, 4};
    vector<int> values = {15, 20, 30};
    int max_value = solution.completeKnapsack(bagWeight, weights, values);
    // 输出最大价值
    printf("The maximum value is: %d\n", max_value);
    return 0;
}
```

## 完全背包与 0-1 背包的区别

1. **选择次数**:
   - 0-1 背包: 每种物品只能选一次。
   - 完全背包: 每种物品可以选无限次。
   
2. **遍历顺序**:
   - 0-1 背包: 内层循环倒序遍历。
   - 完全背包: 内层循环正序遍历。

通过理解和使用这个模板，你可以解决大多数完全背包相关的问题。希望这对你有帮助！